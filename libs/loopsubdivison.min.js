/**
 * @description Loop Subdivision Surface
 * @about       Smooth subdivision surface modifier for use with three.js BufferGeometry.
 * @author      Stephens Nunnally <@stevinz>
 * @license     MIT - Copyright (c) 2022 Stephens Nunnally
 * @source      https://github.com/stevinz/three-subdivide
**/
window.loopSubdivision={},(()=>{function t(t,r=1,n={}){if(arguments.length>3&&console.warn("modify() now uses a parameter object. See readme for more info!"),"object"!=typeof n&&(n={}),void 0===n.split&&(n.split=!0),void 0===n.uvSmooth&&(n.uvSmooth=!1),void 0===n.preserveEdges&&(n.preserveEdges=!1),void 0===n.flatOnly&&(n.flatOnly=!1),void 0===n.maxTriangles&&(n.maxTriangles=1/0),!l(t))return t;let u=t.clone();if(n.split){const t=e(u);u.dispose(),u=t}for(let t=0;t<r;t++){let t=u.attributes.position.count/3;if(t<n.maxTriangles){let t;t=n.flatOnly?o(u):i(u,n),u.groups.forEach(e=>{t.addGroup(4*e.start,4*e.count,e.materialIndex)}),u.dispose(),u=t}}return u}function e(t){function e(t,e,i=!1){const n=4,c=u*t.itemSize*n,s=new t.array.constructor(c),f="position"===e&&!i&&o.groups.length>0;let a=void 0,l=void 0,p=0,v=0,T=t.itemSize;for(let e=0;e<u;e+=3){if(!g[e/3]){v+=3;continue}w.fromBufferAttribute(t,e+0),y.fromBufferAttribute(t,e+1),S.fromBufferAttribute(t,e+2);const i=e/3,n=h[i][0],u=h[i][1],c=h[i][2],B=m[n].length,R=m[u].length,H=m[c].length,$=B+R+H-3,V=3*p/T/3;if(0===$)d(s,p,T,w,y,S),p+=3*T;else{const t=A[n],e=A[u],o=A[c];(t>e||R<=1)&&(t>o||H<=1)&&B>1?(b.copy(w).add(y).divideScalar(2),H>1?(E.copy(S).add(w).divideScalar(2),d(s,p,T,w,b,E),p+=3*T,d(s,p,T,b,S,E),p+=3*T):(d(s,p,T,w,b,S),p+=3*T),R>1?(E.copy(y).add(S).divideScalar(2),d(s,p,T,b,y,E),p+=3*T,d(s,p,T,E,S,b),p+=3*T):(d(s,p,T,y,S,b),p+=3*T)):(e>o||H<=1)&&R>1?(b.copy(y).add(S).divideScalar(2),B>1?(E.copy(w).add(y).divideScalar(2),d(s,p,T,b,E,y),p+=3*T,d(s,p,T,E,b,w),p+=3*T):(d(s,p,T,y,b,w),p+=3*T),H>1?(E.copy(S).add(w).divideScalar(2),d(s,p,T,b,S,E),p+=3*T,d(s,p,T,E,w,b),p+=3*T):(d(s,p,T,S,w,b),p+=3*T)):H>1?(b.copy(S).add(w).divideScalar(2),R>1?(E.copy(y).add(S).divideScalar(2),d(s,p,T,S,b,E),p+=3*T,d(s,p,T,b,y,E),p+=3*T):(d(s,p,T,S,b,y),p+=3*T),B>1?(E.copy(w).add(y).divideScalar(2),d(s,p,T,w,E,b),p+=3*T,d(s,p,T,E,y,b),p+=3*T):(d(s,p,T,w,y,b),p+=3*T)):(d(s,p,T,w,y,S),p+=3*T)}f&&o.groups.forEach(t=>{t.start===e-v&&(void 0!==a&&void 0!==l&&r.addGroup(a,V-a,l),a=V,l=t.materialIndex)}),v=0}const B=3*p/T,R=new t.array.constructor(B);for(let t=0;t<B;t++)R[t]=s[t];return f&&void 0!==a&&void 0!==l&&r.addGroup(a,3*p/T/3-a,l),R}if(!l(t))return t;const o=null!==t.index?t.toNonIndexed():t.clone(),r=new THREE.BufferGeometry,i=a(o),u=o.attributes.position.count,s=o.getAttribute("position"),p=o.getAttribute("normal"),m={},h=[],A={},g=[];for(let t=0;t<u;t+=3){w.fromBufferAttribute(s,t+0),y.fromBufferAttribute(s,t+1),S.fromBufferAttribute(s,t+2),v.fromBufferAttribute(p,t);const e=c(w),o=c(y),r=c(S),i=H.set(w,y,S).getArea();if(g.push(!n(i,0)),!g[t/3]){h.push([]);continue}f(v,w,y,S);const u=c(v),a=[`${e}_${o}_${u}`,`${o}_${e}_${u}`,`${o}_${r}_${u}`,`${r}_${o}_${u}`,`${r}_${e}_${u}`,`${e}_${r}_${u}`],d=t/3;for(let t=0;t<a.length;t++)m[a[t]]||(m[a[t]]=[]),m[a[t]].push(d),A[a[t]]||(0!==t&&1!==t||(A[a[t]]=w.distanceTo(y)),2!==t&&3!==t||(A[a[t]]=y.distanceTo(S)),4!==t&&5!==t||(A[a[t]]=S.distanceTo(w)));h.push([a[0],a[2],a[4]])}i.forEach(t=>{const i=o.getAttribute(t);if(!i)return;const n=e(i,t);r.setAttribute(t,new THREE.BufferAttribute(n,i.itemSize))});const T=o.morphAttributes;for(const t in T){const o=[],i=T[t];for(let r=0,n=i.length;r<n;r++){if(i[r].count!==u)continue;const n=e(i[r],t,!0);o.push(new THREE.BufferAttribute(n,i[r].itemSize))}r.morphAttributes[t]=o}return r.morphTargetsRelative=o.morphTargetsRelative,o.dispose(),r}function o(t){if(!l(t))return t;const e=null!==t.index?t.toNonIndexed():t.clone(),o=new THREE.BufferGeometry,i=a(e),n=e.attributes.position.count;i.forEach(t=>{const i=e.getAttribute(t);i&&o.setAttribute(t,r(i,n))});const u=e.morphAttributes;for(const t in u){const e=[],i=u[t];for(let t=0,o=i.length;t<o;t++)i[t].count===n&&e.push(r(i[t],n));o.morphAttributes[t]=e}return o.morphTargetsRelative=e.morphTargetsRelative,e.dispose(),o}function r(t,e){const o=4,r=e*t.itemSize*o,i=new t.array.constructor(r);let n=0,u=t.itemSize;for(let o=0;o<e;o+=3)w.fromBufferAttribute(t,o+0),y.fromBufferAttribute(t,o+1),S.fromBufferAttribute(t,o+2),A.copy(w).add(y).divideScalar(2),g.copy(y).add(S).divideScalar(2),T.copy(S).add(w).divideScalar(2),d(i,n,u,w,A,T),n+=3*u,d(i,n,u,y,g,A),n+=3*u,d(i,n,u,S,T,g),n+=3*u,d(i,n,u,A,g,T),n+=3*u;return new THREE.BufferAttribute(i,t.itemSize)}function i(t,e={}){function r(t,e,o){S[t]||(S[t]={}),S[t][e]||(S[t][e]=[]),S[t][e].push(o)}function i(t,e){H[t]||(H[t]=[]),H[t].push(e)}function n(t,e){$[t]||($[t]=new Set),$[t].add(e)}function u(t,o,r){const i=f.attributes.position.count*r.itemSize,n=new o.array.constructor(i);let u=0;for(let i=0;i<f.attributes.position.count;i+=3){for(let n=0;n<3;n++)if("uv"!==t||e.uvSmooth)if("normal"===t){B[n].fromBufferAttribute(w,i+n);const t=c(B[n]),e=y[t],o=Object.keys(e).length,u=.75/o,s=1-u*o;R[n].fromBufferAttribute(r,i+n),R[n].multiplyScalar(s),e.forEach(t=>{m.fromBufferAttribute(r,t),m.multiplyScalar(u),R[n].add(m)})}else{R[n].fromBufferAttribute(r,i+n),B[n].fromBufferAttribute(w,i+n);const t=c(B[n]),u=S[t],s=H[t];if(u){if(e.preserveEdges){const e=$[t];let o=!0;for(const t of e)H[t].length%2!=0&&(o=!1);if(!o)continue}const r=Object.keys(u).length,i=1/r*(5/8-Math.pow(3/8+.25*Math.cos(2*Math.PI/r),2)),c=1-i*r;R[n].multiplyScalar(c);for(let t in u){const e=u[t];m.set(0,0,0);for(let t=0;t<e.length;t++)m.add(h.fromBufferAttribute(o,e[t]));m.divideScalar(e.length),m.multiplyScalar(i),R[n].add(m)}}else if(s&&2===s.length){const t=s.length,e=.125,r=1-e*t;R[n].multiplyScalar(r),s.forEach(t=>{m.fromBufferAttribute(o,t),m.multiplyScalar(e),R[n].add(m)})}}else R[n].fromBufferAttribute(r,i+n);d(n,u,r.itemSize,R[0],R[1],R[2]),u+=3*r.itemSize}return n}if("object"!=typeof e&&(e={}),void 0===e.uvSmooth&&(e.uvSmooth=!1),void 0===e.preserveEdges&&(e.preserveEdges=!1),!l(t))return t;const s=null!==t.index?t.toNonIndexed():t.clone(),f=o(s),p=new THREE.BufferGeometry,b=a(s),E=s.attributes.position.count,v=s.getAttribute("position"),w=f.getAttribute("position"),y={},S={},H={},$={};for(let t=0;t<E;t+=3){const e=c(R[0].fromBufferAttribute(v,t+0)),o=c(R[1].fromBufferAttribute(v,t+1)),u=c(R[2].fromBufferAttribute(v,t+2));r(e,o,t+1),r(e,u,t+2),r(o,e,t+0),r(o,u,t+2),r(u,e,t+0),r(u,o,t+1),A.copy(R[0]).add(R[1]).divideScalar(2),g.copy(R[1]).add(R[2]).divideScalar(2),T.copy(R[2]).add(R[0]).divideScalar(2);const s=c(A),f=c(g),a=c(T);i(s,t+2),i(f,t+0),i(a,t+1),n(e,s),n(e,a),n(o,s),n(o,f),n(u,f),n(u,a)}for(let t=0;t<f.attributes.position.count;t++){const e=c(h.fromBufferAttribute(w,t));y[e]||(y[e]=[]),y[e].push(t)}b.forEach(t=>{const e=s.getAttribute(t),o=f.getAttribute(t);if(void 0===e||void 0===o)return;const r=u(t,e,o);p.setAttribute(t,new THREE.BufferAttribute(r,o.itemSize))});const V=s.morphAttributes;for(const t in V){const e=[],o=V[t];for(let r=0,i=o.length;r<i;r++){if(o[r].count!==E)continue;const i=o[r],n=n(o[r],o[r].count),c=u(t,i,n);e.push(new THREE.BufferAttribute(c,n.itemSize))}p.morphAttributes[t]=e}return p.morphTargetsRelative=s.morphTargetsRelative,f.dispose(),s.dispose(),p}function n(t,e,o=1e-5){return t<e+o&&t>e-o}function u(t,e=$){let o=s(t*e);return 0==o&&(o=0),`${o}`}function c(t,e=$){return`${u(t.x,e)},${u(t.y,e)},${u(t.z,e)}`}function s(t){return t+(t>0?.5:-.5)<<0}function f(t,e,o,r){h.subVectors(e,o),t.subVectors(o,r),t.cross(h).normalize()}function a(t){const e=["position","normal","uv"],o=Object.keys(t.attributes),r=Array.from(new Set(e.concat(o)));return r}function d(t,e,o,r,i,n){o>=1&&(t[e+0+0*o]=r.x,t[e+0+1*o]=i.x,t[e+0+2*o]=n.x),o>=2&&(t[e+1+0*o]=r.y,t[e+1+1*o]=i.y,t[e+1+2*o]=n.y),o>=3&&(t[e+2+0*o]=r.z,t[e+2+1*o]=i.z,t[e+2+2*o]=n.z),o>=4&&(t[e+3+0*o]=r.w,t[e+3+1*o]=i.w,t[e+3+2*o]=n.w)}function l(t){return void 0===t?(console.warn("window.loopSubdivision: Geometry provided is undefined"),!1):t.isBufferGeometry?void 0===t.attributes.position?(console.warn("window.loopSubdivision: Geometry provided missing required 'position' attribute"),!1):(void 0===t.attributes.normal&&t.computeVertexNormals(),!0):(console.warn("window.loopSubdivision: Geometry provided is not 'BufferGeometry' type"),!1)}const p=2,m=new THREE.Vector3,b=new THREE.Vector3,E=new THREE.Vector3,v=new THREE.Vector3,h=new THREE.Vector3,w=new THREE.Vector3,y=new THREE.Vector3,S=new THREE.Vector3,A=new THREE.Vector3,g=new THREE.Vector3,T=new THREE.Vector3,B=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3],R=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3],H=new THREE.Triangle;window.loopSubdivision.modify=t;const $=Math.pow(10,p)})();